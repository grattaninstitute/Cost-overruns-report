\documentclass{grattan}
\input{tex/preamble}



\title{Cost overruns}
\author{Marion Terrill}

\GrattanReportNumber{XX}

\acknowledgements{..}




\catcode`\$=12
\begin{document}
<<portability, echo=FALSE>>=
source("R/portability.R")
portability()
@

<<knitrOpts, echo=FALSE>>=
library(knitr)
opts_chunk$set(error = FALSE, echo = FALSE, message = FALSE, fig.width=11, fig.height=7, out.width="\\columnwidth", out.height=paste0("0.6363\\columnwidth"))
@

<<loadPackages, cache=FALSE>>=
library(testthat)
library(dplyr)
library(data.table)
library(dtplyr)
library(magrittr)
library(tidyr)
library(zoo)
library(ggplot2)
library(scales)
library(devtools)
library(CostOverrunsData)
if (packageVersion("CostOverrunsData") < package_version('0.2.0')){
  stop("Update the CostOverrunsData package. Pull from github master then build locally.")
}
library(grattan)
if (texNum(1.25, dollar = TRUE) != "\\$1.25"){
  stop("Update the grattan package")  # recent bugfix
}
library(broom)
library(sandwich)
library(car)
library(mfx)
library(logistf)
library(curl)
library(digest)
library(glmnet)
# Namespace
select <- function(...) dplyr::select(...)
rename <- function(...) dplyr::rename(...)
@

<<n2w>>=
#' @title Numbers to words
#' @source \url{https://github.com/ateucher/useful_code/blob/master/R/numbers2words.r}
n2w <- function(x){
  c("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten")[x]
}
@

<<val_nrst_mean>>=
#' Returns the value in a set nearest to its mean
#' @param x A numeric vector
#' @param ... Arguments passed to \code{mean}.
val_nrst_mean <- function(x, ...){
  avg <- mean(x, ...)
  diffs <- abs(avg - x)
  # floating point precision not an issue
  if (any(diffs == 0)){
    return(avg)
  } else {
    return(x[which.min(diffs)])
  }
}

test_that("Returns mean if there", {
  expect_equal(mean(c(0.1, 0.3, 0.5)), val_nrst_mean(c(0.1, 0.3, 0.5)))
})

test_that("Returns nearest otherwise", {
  expect_equal(val_nrst_mean(c(0.1, 0.35, 0.5)), 0.35)
})
@

<<>>=
# This will equal 1.661184 if the inflator's working correctly:
# general_inflator(from = as.yearqtr("1998 Q1"), to = as.yearqtr("2013 Q1"), inflator_table = construction_indices)
construction_indices2 <- 
  construction_indices %>%
  as.data.table %>%
  copy %>%
  .[, Time := as.Date(Time)]

construction_inflator <- function(x = 1, from, to){
  general_inflator(x = x, from = from, to = to, inflator_table = construction_indices2)
}

test_that("Construction inflator returns single correct value", {
  expect_equal(construction_inflator(1, from = as.Date("1998-03-01"), to = as.Date("2013-03-01")), 1.66118421052632)
})

test_that("Construction inflator works multiply", {
  expect_equal(construction_inflator(c(1, 2), from = as.Date(c("1998-03-01", "2000-03-01")), to = as.Date("2013-03-01")), 
               c(1.66118421052632, 3.05135951661631))
})
@

<<public_private_by_Grattan_record>>=
public_private_by_Grattan_record <- 
  completed_project_list  %>%
  as.data.table %>%
  setkey(Grattan_record) %>%
  unique %>%
  # no need to spread info over two columns
  mutate(Lucille_Ownership = if_else(as.logical(Public_project_Grattan), 
                                     "Public", 
                                     "Private")) %>%
  # Manual done by Lucille
  # Correcting errors in the Lucille_ownership variable
  mutate(Lucille_Ownership = if_else(Grattan_record %in% c(10218, 10858, 11043, 11127, 8267, 9757, 7952), 
                                     "Private", 
                                     Lucille_Ownership)) %>%
  select(Grattan_record, Lucille_Ownership)
@

<<convert_million_cols>>=
convert_million_cols <- function(.data){
  stopifnot(is.data.table(.data))
  cols_in_millions <- grep("$m", names(.data), fixed = TRUE)
  
  for (j in cols_in_millions){
    set(.data, j = j, value = .data[[j]] * 10^6)
  }
  
  # Update the names also
  setnames(.data, 
           old = names(.data)[cols_in_millions], 
           trimws(gsub("$m", "", fixed = TRUE, gsub("($m)", "", names(.data)[cols_in_millions], fixed = TRUE))))
  .data
}

test_that("convert_million_cols", {
  example.dt <- data.table(x = 1:5, y = 1:5)
  setnames(example.dt, "x", "x ($m)")
  
  expect_identical(convert_million_cols(example.dt), 
                   data.table(x = seq(1e6, 5e6, by = 1e6), y = 1:5))
})
@

<<project_dataset_orig>>=
project_dataset_orig <- copy(project_dataset)
@

<<project_dataset>>=
project_dataset <-
  project_dataset_orig %>%
  as.data.table %>%
  # case-sensitivity
  mutate(Status = if_else(Status == "Under Construction", "Under construction", Status)) %>%
  mutate(Status_4 = Status) %>% # 4 stands for four stages: "Possible", "Under consideration", "Committed", "Under construction"
  mutate(Status = if_else(Status %in% c("Possible", "Under consideration"), "Possible or under consideration", Status)) %>%
  mutate(Grattan_record = coalesce(`Project No.`, `Record No`), 
         Record_date = as.Date(paste("1", sheet), 
                               format = "%d %b %Y")) %>%
  filter(!is.na(Grattan_record))
@

<<first_status_by_GR>>=
first_status_by_GR <-
  project_dataset %>%
  as.data.table %T>%
  {warning("What about DELETED?")} %>%
  mutate(Status_ordered = factor(Status, 
                                 levels = c("Possible or under consideration", "Committed", "Under construction"), 
                                 ordered = TRUE)) %>%
  group_by(Grattan_record) %>%
  summarise(first_pipeline_status = first(Status_ordered, order_by = Record_date)) %>%
  setkey(Grattan_record)
@

<<final_status_by_GR>>=
#' @return Data table of **all** records by their final status as recorded. 
final_status_by_GR <- 
  historical_dataset %>% 
  as.data.table %>%
  select(Grattan_record = `Project No.`, 
         Status_according_to_historical_dataset = Status) %>%
  # See https://github.com/grattaninstitute/Cost-overruns-report/issues/20 
  right_join(project_dataset, by = "Grattan_record") %>%
  group_by(Grattan_record) %>%
  summarise(Final_status = 
              # i.e. it is not in historical_dataset:
              if (all(is.na(Status_according_to_historical_dataset))){
                if (any(Status == "Under construction") && year(max(Record_date)) < 2015){
                  "Completed"
                } else {
                  NA_character_
                }
              } else {
                last(Status_according_to_historical_dataset, order_by = Record_date)
              }) %>%
  setkey(Grattan_record)
@

<<date_first_Deleted_by_GR>>=
date_first_Deleted_by_GR <-
  historical_dataset %>% 
  as.data.table %>%
  select(Grattan_record = `Project No.`, 
         Status_according_to_historical_dataset = Status) %>%
  # See https://github.com/grattaninstitute/Cost-overruns-report/issues/20 
  right_join(project_dataset, by = "Grattan_record") %>%
  mutate(Status = coalesce(Status_according_to_historical_dataset, Status)) %>%
  mutate(isDeleted = Status == "Deleted") %>%
  group_by(Grattan_record) %>%
  summarise(date_first_Deleted = if (any(isDeleted)) min(Record_date[which(isDeleted)]) else as.Date(Inf))
@

<<isTransport_by_GR>>=
isTransport_by_GR <- 
  project_dataset %>%
  mutate(isTransport = `&`(`Major industry` == "Transport & Storage",
                           `Sub-industry` %in% c("Road", "Rail"))) %>%
  select(Grattan_record, isTransport) %>%
  setkey(Grattan_record) %>%
  unique
@

<<Cost_estimate_by_GR_Record_date>>=
Cost_estimate_by_GR_Record_date <- 
  project_dataset %>%
  as.data.table %>%
  select(Grattan_record, Record_date, sheet, Status, grep("Cost", names(.), ignore.case = TRUE, value = FALSE)) %>%
  melt.data.table(measure.vars = grep("Cost", names(.), ignore.case = TRUE, value = TRUE), 
                  na.rm = TRUE, 
                  value.name = "Cost_estimate") %>%
  setkey(Grattan_record) %T>%
  ## Testing:
  {
    dot <- copy(.)
    test_that("Each cost variable is unique", {
      nrows_not_unique <- 
        setkey(dot, 
               Grattan_record, 
               variable, 
               sheet) %>% 
        unique %>% 
        group_by(Grattan_record, sheet) %>% 
        mutate(n = uniqueN(variable)) %>% 
        filter(n > 1) %>%
        nrow
      expect_equal(nrows_not_unique, 0)
    })
  } %>%
  # molten state no longer needed
  select(-variable) %>%
  {
    # Warning("Assuming cost columns not marked ($m) are nonetheless in millions") - yes, that's a fine assumption. 
    mutate(., Cost_estimate = Cost_estimate * 10^6) 
  } %>%
  {
    dot <- .
    
    # What date should we choose to inflate
    # cost estimates by? A: construction phase, 
    # as defined below.
    inflation_origin_by_GR <- 
      dot %>%
      # Is the status under construction in this quarter?
      mutate(.co = grepl("under.*construction", Status, ignore.case = TRUE)) %>%
      group_by(Grattan_record) %>%
      # For each grattan record, 
      #  1.  Is the project ever under construction?  If so, take
      #      the value nearest the mean of those dates which were
      #      under construction.
      #  2.  If the project is never under construction, take the
      #      the val_nrst_mean of all dates.
      summarise(
        inflation_origin = 
          if (any(.co)) { 
            val_nrst_mean(Record_date[.co]) 
          } else { 
            val_nrst_mean(Record_date)
          }
      ) %>%
      select(Grattan_record, inflation_origin) %>%
      setkey(Grattan_record)
    
    # Return to the top-level pipe:
    merge(dot, inflation_origin_by_GR)
  } %>%
  mutate(Cost_estimate_real = construction_inflator(Cost_estimate, from = inflation_origin, to = as.Date("2015-12-01"))) %>% 
  select(Grattan_record, Record_date, Cost_estimate, Cost_estimate_real) %>%
  setkey(Grattan_record, Record_date)
@

<<Status_ordered_by_GR>>=
#' @details Note that 'Deleted' is confusing: it really should be a separate field.
#'          Deleted is a property of the project with respect to the dataset, whereas
#'          the other statuses are properties of the project independent of the dataset. 
Status_ordered_by_GR_Record_date <- 
  project_dataset %>%
  copy %>%
  select(Grattan_record, Record_date, Status) %>%
  filter(Status != "Deleted") %>%
  mutate(Status_ordered = factor(Status, 
                                 levels = c("Possible or under consideration", 
                                            "Committed", 
                                            "Under construction"), 
                                 ordered = TRUE)) %>%
  select(Grattan_record, Record_date, Status) %>%
  setkey(Grattan_record, Record_date) %>%
  unique
@

<<first_Cost_estimate_real_by_GR>>=
first_Cost_estimate_real_by_GR <- 
  Cost_estimate_by_GR_Record_date %>%
  group_by(Grattan_record) %>%
  summarise(first_Cost_estimate_real = first(Cost_estimate_real, order_by = Record_date)) %>%
  setkey(Grattan_record)
@

<<last_Cost_estimate_real_by_GR>>=
last_Cost_estimate_real_by_GR <- 
  Cost_estimate_by_GR_Record_date %>%
  group_by(Grattan_record) %>%
  summarise(last_Cost_estimate_real = last(Cost_estimate_real, order_by = Record_date)) %>%
  setkey(Grattan_record)
@

<<outlier_by_GR>>=
outlier_by_GR <- 
  first_Cost_estimate_real_by_GR %>%
  merge(last_Cost_estimate_real_by_GR) %>%
  mutate(outlier = !between(last_Cost_estimate_real / first_Cost_estimate_real,
                            0.5, # This is a generous definition of outliers as the biggest underrun we observe 
                            # is the 34% underrun on the Springfield to Richlands line. 
                            
                            5.2  # Any overrun greater than 5.2 is suspect of a data error. This is because the 
                            # Peel deviation is the project with the largest overrun that we have been able 
                            # to verify with certainty. A bunch of the extreme outliers were all redcorded 
                            # on the same day, which looks suspicious too.
  ) | is.na(first_Cost_estimate_real) | is.na(last_Cost_estimate_real)) %>%
  select(Grattan_record, outlier) %>%
  setkey(Grattan_record)
@

<<inflation_origin_by_GR>>=
inflation_origin_by_GR <- 
  project_dataset %>%
  # Is the status under construction in this quarter?
  mutate(.co = grepl("under.*construction", Status, ignore.case = TRUE)) %>%
  group_by(Grattan_record) %>%
  # For each grattan record, 
  #  1.  Is the project ever under construction?  If so, take
  #      the value nearest the mean of those dates which were
  #      under construction.
  #  2.  If the project is never under construction, take the
  #      the val_nrst_mean of all dates.
  summarise(
    inflation_origin = 
      if (any(.co)) { 
        val_nrst_mean(Record_date[.co]) 
      } else { 
        val_nrst_mean(Record_date)
      }
  ) %>%
  select(Grattan_record, inflation_origin) %>%
  setkey(Grattan_record)
@

<<transport_projects_with_outliers>>=
transport_projects_with_outliers <- 
  project_dataset %>%
  merge(readRDS("./data/State_decoding.rds"), by = "State", sort = FALSE) %>% 
  filter(`Major industry` == "Transport & Storage",
         `Sub-industry` %in% c("Road", "Rail")) %>%
  filter(Status != "Deleted") %>%
  mutate(Status_ordered = factor(Status, 
                                 levels = c("Possible or under consideration", "Committed", "Under construction"), 
                                 ordered = TRUE)) %>%
  mutate(Grattan_record = coalesce(`Project No.`,
                                   `Record No`)) %>%
  select(-`Record No`, -`Project No.`) %>%
  setkey(Grattan_record) %>%
  # Convert all 'cost' names to the same
  melt.data.table(measure.vars = grep("Cost", names(.), ignore.case = TRUE, value = TRUE), 
                  na.rm = TRUE, 
                  value.name = "Cost_estimate") %T>%
  ## Testing:
                  {
                    dot <- copy(.)
                    test_that("Each cost variable is unique", {
                      nrows_not_unique <- 
                        setkey(dot, 
                               Grattan_record, 
                               variable, 
                               sheet) %>% 
                        unique %>% 
                        group_by(Grattan_record, sheet) %>% 
                        mutate(n = uniqueN(variable)) %>% 
                        filter(n > 1) %>%
                        nrow
                      expect_equal(nrows_not_unique, 0)
                    })
                  } %>%
  # molten state no longer needed
  select(-variable) %>%
  {
    # Warning("Assuming cost columns not marked ($m) are nonetheless in millions") - yes, that's a fine assumption. 
    mutate(., Cost_estimate = Cost_estimate * 10^6) 
  } %>%
  setkey(Grattan_record) %>%
  merge(public_private_by_Grattan_record) %>%
  # Correcting errors in the Lucille_ownership variable
  mutate(Lucille_Ownership = if_else(Grattan_record %in% c(10218, 10858, 11043, 11127, 8267, 9757, 7952), "Private", Lucille_Ownership)) %>%
  filter(Lucille_Ownership == "Public") %>%
  
  {
    dot <- .
    
    # What date should we choose to inflate
    # cost estimates by? A: construction phase, 
    # as defined below.
    
    
    # Return to the top-level pipe:
    merge(dot, inflation_origin_by_GR)
  } %>%
  mutate(Cost_estimate_real = construction_inflator(Cost_estimate, from = inflation_origin, to = as.Date("2015-12-01"))) %>%
  setkey(Grattan_record, Record_date) %>%
  group_by(Grattan_record) %>%
  filter(last(Cost_estimate_real, order_by = Record_date) >= 20e6) 

@

<<transport_projects_with_outliers_and_cost_overrun_variables>>=
transport_projects_with_outliers_and_cost_overrun_variables <- 
  transport_projects_with_outliers %>%
  # first and last should refer to the first non-NA value
  #  (Does not appear to be necessary)
  # mutate(Cost_estimate_filled = pmax(na.locf(Cost_estimate, na.rm = FALSE), 
  #                                    na.locf(Cost_estimate, na.rm = FALSE, fromLast = TRUE), 
  #                                    na.rm = TRUE)) %>%
  group_by(Grattan_record) %>%
  summarise(final_cost_estimate_real = last(Cost_estimate_real, order_by = Record_date), 
            first_cost_estimate_real = first(Cost_estimate_real, order_by = Record_date)) %>%
  ungroup %>%
  mutate(cost_overrun = final_cost_estimate_real - first_cost_estimate_real,
         Final_cost_over_initial = final_cost_estimate_real / first_cost_estimate_real) %>%
  ungroup %>%
  mutate(outlier = !between(Final_cost_over_initial,
                            0.5, # This is a generous definition of outliers as the biggest underrun we observe 
                            # is the 34% underrun on the Springfield to Richlands line. 
                            
                            5.2  # Any overrun greater than 5.2 is suspect of a data error. This is because the 
                            # Peel deviation is the project with the largest overrun that we have been able 
                            # to verify with certainty. A bunch of the extreme outliers were all redcorded 
                            # on the same day, which looks suspicious too.
  )) %>%
  setkey(Grattan_record)

@

<<transport_projects>>=
transport_projects <-
  project_dataset %>%
  as.data.table %>% 
  setkey(Grattan_record, Record_date) %>% 
  merge(Cost_estimate_by_GR_Record_date) %>% 
  setkey(Grattan_record) %>% 
  merge(isTransport_by_GR) %>% 
  merge(public_private_by_Grattan_record) %>% 
  filter(isTransport, 
         Lucille_Ownership == "Public") %>% 
  group_by(Grattan_record) %>% 
  filter(last(Cost_estimate, order_by = Record_date) >= 20e6)
@

<<n_transport_projects>>=
n_transport_projects <-
  transport_projects %$% 
  uniqueN(Grattan_record)
@

<<n_deleted_transport_projects>>=
n_deleted_transport_projects <-
  final_status_by_GR %>%
  merge(transport_projects) %$% 
  sum(Final_status == "Deleted", na.rm = TRUE) 
@

<<n_completed_transport_projects>>=
n_completed_transport_projects <-
  final_status_by_GR %>%
  merge(transport_projects) %$% 
  sum(Final_status == "Completed", na.rm = TRUE) 
@

<<cease-knit>>=
warning("Ceasing")
knitr::opts_chunk$set(eval = FALSE)
@

<<cancellation_by_project_stage, eval=FALSE>>=
cancellation_by_project_stage <-
  transport_projects %>%
  setkey(Grattan_record) %>%
  unique() %>%
  select(Grattan_record) %>%
  merge(first_status_by_GR) %>%
  merge(final_status_by_GR) %>%
  mutate(n_first_status_possible_or_under_consideration = length(which(first_pipeline_status == "Possible or under consideration")),
         n_first_status_committted = length(which(first_pipeline_status == "Committed")),
         n_first_status_under_construction = length(which(first_pipeline_status == "Under construction")),
         
         n_deleted_as_possible_or_under_consideration = length(which(final_pipeline_status == "Possible or under consideration" & Final_status == "Deleted")),
         n_deleted_as_committted = length(which(final_pipeline_status == "Committed" & Final_status == "Deleted")),
         n_deleted_as_under_construction = length(which(final_pipeline_status == "Under construction" & Final_status == "Deleted")),
         
         n_projects_w_possible_or_under_consideration = n_first_status_possible_or_under_consideration, 
         n_projects_w_committted = n_projects_w_possible_or_under_consideration + n_first_status_committted - n_deleted_as_possible_or_under_consideration,
         n_projects_w_under_construction = n_projects_w_committted + n_first_status_under_construction - n_deleted_as_committted,
         
         possible_or_under_consideration_cancellation_rate = n_deleted_as_possible_or_under_consideration/n_projects_w_possible_or_under_consideration, 
         committed_cancellation_rate = n_deleted_as_committted/n_projects_w_committted,
         under_construction_cancellation_rate = n_deleted_as_under_construction/n_projects_w_under_construction, 
         overrall_cancellation_rate = length(which(Final_status == "Deleted"))/length(Final_status)) %>%
  select(possible_or_under_consideration_cancellation_rate, possible_or_under_consideration_cancellation_rate, committed_cancellation_rate, under_construction_cancellation_rate,   overrall_cancellation_rate) %>%
  unique

@

<<cancellation_and_cost_overruns, eval=FALSE>>=
cancellation_and_cost_overruns <-
  transport_projects_with_outliers_and_cost_overrun_variables %>%
  filter(!outlier) %>%
  merge(first_status_by_GR) %>%
  merge(final_status_by_GR) %>%
  mutate(cancellation_state = if_else(Final_status== "Completed" , "None", as.character(final_pipeline_status)), 
         cancellation_state = factor(cancellation_state, 
                                 levels = c("Possible or under consideration",
                                      "Committed",
                                      "Under construction",
                                      "None"), 
                                 ordered = TRUE)) %>%
  mutate()

  # I'm going to write out each of the regressions, then work out a way to do all of this within the table and just report the relevant mfx's and pvals
  #cancellation_reg_P <- logitmfx(factor(cancellation_state== "Possible")~ Final_cost_over_initial, cancellation_and_cost_overruns) # This needs to be based off cost overruns up to that point, not overrall


  
@

<<cost_when_completed>>=
cost_when_completed <-
  historical_dataset %>%
  as.data.table %>%
  mutate(cost_when_completed = `Total cost $m`*10^6, Grattan_record = `Project No.`) %>%
  setkey(Grattan_record) %>%
  select(cost_when_completed, Grattan_record)


@

<<completed_transport_projects>>=
completed_transport_projects <- 
 final_status_by_GR %>%
  merge(cost_when_completed) %>%
  merge(inflation_origin_by_GR) %>%
  mutate(cost_when_completed_real = construction_inflator(cost_when_completed, from = inflation_origin, to = as.Date("2015-12-01"))) %>%
  filter(Final_status == "Completed")

@

<<Prop_projects_w_each_project_stage>>=
Prop_projects_w_each_project_stage <-
  completed_transport_projects %>%
  setkey(Grattan_record) %>%
  unique() %>%
  select(Grattan_record) %>%
  merge(first_status_by_GR) %>%
  merge(final_status_by_GR) %>%
  mutate(total_n_projects = length(Grattan_record), 
         
         n_first_status_possible_or_under_consideration = length(which(first_pipeline_status == "Possible or under consideration")),
         n_first_status_committted = length(which(first_pipeline_status == "Committed")),
         n_first_status_under_construction = length(which(first_pipeline_status == "Under construction")),

         prop_projects_w_possible_or_under_consideration = n_first_status_possible_or_under_consideration/total_n_projects, 
         prop_projects_w_committted = (n_first_status_possible_or_under_consideration + n_first_status_committted)/total_n_projects,
         prop_projects_w_under_construction = (n_first_status_possible_or_under_consideration + n_first_status_committted+ n_first_status_under_construction )/total_n_projects) %>%
  select(prop_projects_w_possible_or_under_consideration, prop_projects_w_committted, prop_projects_w_under_construction) %>%
  unique()
         
@


<<first_date_by_Status_GR>>=
first_date_by_Status_GR <- 
  completed_transport_projects %>%
  group_by(Grattan_record, Status_ordered) %>%
  summarise(first_date = min(Record_date)) %>%
  setkey(Grattan_record, Status_ordered)
@

<<completed_transport_project_date_range>>=
completed_transport_project_date_range <- 
  completed_transport_projects %>% 
  group_by(Grattan_record) %>% 
  summarise(last_date = max(Record_date)) %$% 
  range(last_date)
@

<<cost_overruns_by_GR>>=
cost_overruns_by_GR <-
  completed_transport_projects %>%
  select(Grattan_record, cost_overrun, Final_cost_over_initial, final_cost_estimate_real, first_cost_estimate_real) %>%
  setkey(Grattan_record) %>%
  unique()

@

<<total_cost_of_overruns>>=
total_cost_of_overruns <- 
  cost_overruns_by_GR %$%
  sum(cost_overrun)
@

<<Final_cost_over_initial_by_GR>>=
Final_cost_over_initial_by_GR <- 
  completed_transport_projects %>%
  group_by(Grattan_record) %>%
  mutate(Final_cost_over_initial = 
           last(Cost_estimate, order_by = Record_date) / 
           first(Cost_estimate, order_by = Record_date)) %>% 
  setkey(Grattan_record) %>%
  unique %>% 
  select(Grattan_record, Final_cost_over_initial)


@

<<n_completed_transport_projects_gt_20M>>=
n_completed_transport_projects_gt_20M <- 
  completed_transport_projects %>%
  # inner join (strict)
  merge(Final_cost_over_initial_by_GR) %$%
  uniqueN(Grattan_record)

# Note: all projects in completed transport projects are > $20m.
@

<<savings_if_every_cost_overrun_over_10pc_was_only_10pc>>=
savings_if_every_cost_overrun_over_10pc_was_only_10pc <-
  cost_overruns_by_GR %>%
  filter(final_cost_estimate_real > 1.1 * first_cost_estimate_real) %>%
  mutate(value_of_10_pc_overrun = 0.1 * first_cost_estimate_real, 
         value_of_overruns_gt_10_pc = cost_overrun - value_of_10_pc_overrun) %$%
  sum(value_of_overruns_gt_10_pc)
@

<<prop_projects_on_or_under_budget>>=
prop_projects_on_or_under_budget <- 
  cost_overruns_by_GR %$%
  mean(final_cost_estimate_real <= first_cost_estimate_real)

@

<<prop_projects_exactly_on_budget>>=
prop_projects_exactly_on_budget <- 
  cost_overruns_by_GR %$%
  mean(near(final_cost_estimate_real, first_cost_estimate_real))
@

<<prop_projects_w_overrun_gt>>=
prop_projects_w_overrun_gt <- function(percentage_over){
  cost_overruns_by_GR %$%
    mean(Final_cost_over_initial > 1 + percentage_over)
}
@

<<val_projects_w_overrun_gt>>=
val_projects_w_overrun_gt <- function(percentage_over){
  cost_overruns_by_GR %>%
    mutate(is_over = (final_cost_estimate_real / first_cost_estimate_real) > (1 + percentage_over)) %$%
    sum(is_over * cost_overrun)
}
  
@

<<prop_val_projects_w_overrun_gt>>=
prop_val_projects_w_overrun_gt <- function(percentage_over){
  cost_overruns_by_GR %>%
    mutate(is_over = (cost_overrun / first_cost_estimate_real) > (1 + percentage_over)) %$%
    weighted.mean(is_over, cost_overrun)
}
@

<<pc_lower_ROI>>=
pc_lower_ROI <- 
  cost_overruns_by_GR %$%
  # LD working: (Initial_BCR - BCR_after_COs)/Initial_BCR, 
  # where BCR_after_COs = Benefits/(Initial costs*(sum(Final_costs)/sum(Initial_costs))) and Initial_BCR = Benefits/Initial_costs. 
  {1 - (sum(first_cost_estimate_real) / sum(final_cost_estimate_real))}
@

<<spending_per_dollar_budgeted>>=
spending_per_dollar_budgeted <- 
  cost_overruns_by_GR %$%
  {sum(final_cost_estimate_real) / sum(first_cost_estimate_real)}
@

<<average_mag_of_CO>>=
average_mag_of_CO <- 
  cost_overruns_by_GR %$%
  {mean(final_cost_estimate_real/first_cost_estimate_real)}
@

<<prop_projects_w_overrun>>=
prop_projects_w_overrun <- 
  cost_overruns_by_GR %$%
  mean(Final_cost_over_initial > 1)
@

<<CO_and_project_size_scatter>>=
CO_and_project_size_scatter <-
  completed_transport_projects %>%
  filter(Status == "Under construction") %>%
  setkey(Grattan_record) %>%
  unique() %>%
  setkey(Grattan_record, Record_date) %>%
  group_by(Grattan_record) %>%
  mutate(project_size = first(Cost_estimate_real)) %>%
  select(Grattan_record, project_size, Final_cost_over_initial)

plot(CO_and_project_size_scatter$Final_cost_over_initial, (CO_and_project_size_scatter$project_size))

@

<<CO_and_project_size_categories, eval= FALSE>>=
library(plyr)
library(DescTools)

View(CO_and_project_size_scatter$Grattan_record, CO_and_project_size_scatter$Cost_estimate_real)


CO_and_project_size_scatter$project_size

Cost_overruns_by_project_size<-
  CO_and_project_size_scatter %>%
  mutate(experienced_overrun = if_else(Final_cost_over_initial>1, 1, 0),
        Project_size_category = DescTools::RoundTo(project_size, 100000000, ceiling),
        Project_size_category = if_else(Project_size_category>300, "gt 300", as.character(Project_size_category)), 
        Project_size_category = if_else(Project_size_category!=100, as.character(Project_size_category), if_else(project_size<=50, "50", "100"))) %>%
  group_by(Project_size_category) %>%
  mutate(Mean_overrun = mean(Final_cost_over_initial), 
         pc_w_overrun = mean(experienced_overrun)) %>%
  summarise(Project_size_category, Mean_overrun, pc_w_overrun) %>%
  unique
  

@


\setlength{\overviewExtra}{-4mm}
\begin{overview}
Over the past 15 years, Australian governments have spent \$25~billion more on transport infrastructure than they told taxpayers they would spend.
The cost overruns amounted to nearly a quarter of total project budgets.
Western Australia's Forrest Highway between Perth and Bunbury cost nearly five times, and New South Wales' Hunter Expressway cost nearly four times, the amounts initially promised.
Yet despite their sometimes staggering size, cost overruns attract little public attention.
They are seen as a fact of life in infrastructure building.
This perception can and must be changed.

Cost overruns are a problem less because of how often they happen than their cost when they do.
Eighty eight per cent of Australia's cost overrun problem is explained by the 17 per cent of projects that exceed their promised cost by more than half.

Much of the problem is entirely preventable.
Premature announcements -- when a politician promises to build a road or rail line at a certain cost, often in the lead-up to an election -- are the biggest culprits.
Although only 31 per cent of projects are announced early, early announcements account for 82 per cent of the value of cost overruns over the past 15~years.
Prematurely announced projects need larger cost upgrades not just early on, but throughout their funding approval and construction phases.

For the first time in Australia, we report on all 800 projects valued at \$20~million or more and planned or built since 2000.
We also report on the full project lifecycle from its first funding promise, because, once politicians have announced a project, they and the public treat that announcement as a commitment.
They are right to do so: 80 per cent of these projects end up being built.

Promising to build infrastructure for a lower sum than it finally costs systematically represents infrastructure projects as more attractive than they really are.
Much of the money might be better spent on other priorities.
Understatement of costs also prevents decision-makers from choosing projects with the highest net community benefits, and leads them to choose the wrong ones.

All main political parties have committed to sound analysis and planning of infrastructure, to avoiding waste, and to making decisions with broad social benefit.
Governments should not be able to commit public money before tabling proper evaluation and the underlying business case in parliament.
Once a project is completed, governments should report to the public on how it performed against the cost-benefit estimates behind the original investment decision.
Stand-alone legislation for big projects would encourage bipartisanship when risk and complexity are high.

Not all overruns can be prevented.
Anticipated risks and unforeseen events sometimes come to pass.
The best way to predict and prepare for such events is to learn from history.
But Australian governments do not collect and share information about completed projects, and as a result, project experts systematically under-estimate project costs.

The impact of not learning from history continues to be felt.
Multi-billion dollar projects such as Melbourne's Western Distributor, Sydney's WestConnex and the Inland Rail between Melbourne and Brisbane have much more optimistic cost estimate profiles than those that history would lead us to expect.
We can do better.
Our infrastructure systems should promise what is worth having, and then deliver what is promised.
\end{overview}

\contentspage

\chapter{a}


\end{document}

